pipeline {
   agent any
   
   parameters {
      string(
      name: 'APPLICATION_NAME',
      defaultValue: 'systemone',
      description: 'Name of the application that Helm chart will be updated'
      )
   }
   
   stages {
      stage("Determine Docker Artifacts") {
         steps {
            script {
               // Define allowed apps
               def allowedApps = ["systemone", "alvin", "diva"]
               if (!allowedApps.contains(params.APPLICATION_NAME)) {
                  error("Invalid APPLICATION_NAME '${params.APPLICATION_NAME}'. Must be one of: ${allowedApps.join(', ')}")
               }
               
               // Define Docker image lists
               def coraDockers = [
               "cora-docker-jsclient", "cora-docker-solr", "cora-docker-fedora",
               "cora-docker-rabbitmq", "cora-docker-iipimageserver", "cora-docker-binaryconverter",
               "cora-docker-idplogin", "cora-docker-login", "cora-docker-gatekeeper"
               ]
               def dockerMap = [
               "systemone": coraDockers + ["systemone-docker-postgresql", "systemone-docker", "systemone-docker-fitnesse"],
               "alvin"    : coraDockers + ["alvin-docker-postgresql", "alvin-docker-cora", "alvin-docker-gatekeeper", "alvin-cora-docker-fitnesse"],
               "diva"     : coraDockers + ["diva-docker-postgresql", "diva-cora-docker-fitnesse", "diva-docker-cora", "diva-docker-gatekeeper"]
               ]
               
               // Helper: Fetch latest release or fallback
               def getLatestVersion = {
                  groupId, artifactId, repoUrl ->
                  def groupPath = groupId.replace('.', '/')
                  def metadataUrl = "${repoUrl}/${groupPath}/${artifactId}/maven-metadata.xml"
                  echo "Fetching: ${metadataUrl}"
                  
                  def metadata = new XmlSlurper().parse(metadataUrl)
                  
                  //def metadata = new XmlSlurper().parse(metadataUrl.toURL())
                  def releaseVersion = metadata.versioning.release?.text()
                  
                  if (!releaseVersion) {
                     releaseVersion = "Not released yet"
                     echo "Warning: No <release> found for ${artifactId}, using default: ${releaseVersion}"
                  }
                  
                  return releaseVersion
               }
               
               // Helper: Use group and repo constants
               def getLatestVersionByArtifactId = {
                  artifactId ->
                  def groupId = 'se.uu.ub.cora'
                  def repoUrl = 'http://epc.ub.uu.se/nexus/repository/maven-public/'
                  def latestVersion = getLatestVersion(groupId, artifactId, repoUrl)
                  echo "Latest version of ${groupId}:${artifactId} is ${latestVersion}"
                  return latestVersion
               }
               
               // Get relevant docker list
               def dockerList = dockerMap.get(params.APPLICATION_NAME, coraDockers)
               echo "Updating Helm chart for ${params.APPLICATION_NAME}"
               echo "Dockers to step up: ${dockerList.join(', ')}"
               
               // Iterate and resolve versions
               dockerList.each {
                  artifactId ->
                  getLatestVersionByArtifactId(artifactId.trim())
               }
               
               // Map to hold artifact -> version
               def versionsMap = [:]
               dockerList.each {
                  artifactId ->
                  def version = getLatestVersionByArtifactId(artifactId)
                  versionsMap[artifactId] = version
               }
               
               // Save versionsMap to env for next stage or keep in variable
               // Here we keep it in current script scope as you update file in next step
               echo "Versions map: ${versionsMap}"
               
               // Save to file or pass around as needed
               writeFile file: 'versions.json', text: groovy.json.JsonOutput.toJson(versionsMap)
            }
            
         }
      }
   }
   stage("checkout") {
      steps {
         def projectName = 'cora-deployment-onlyForTest'
         withCredentials([string(credentialsId: '9af4f5c5-4a09-4bbe-9436-2c102765d85b', variable: 'TOKEN'),string(credentialsId: '04bc33f5-abdd-4486-b43b-a5900f6fc080', variable: 'USERNAME')]) {
            sh 'git clone https://$TOKEN@github.com/lsu-ub-uu/$projectName.git $projectNam'
         }
      }
   }
  // stage('Update values.yaml') {
  //    steps {
  //       script {
  //          def yamlFile = readFile('values.yaml')
  //          def versionsJson = readFile('versions.json')
  //          def versionsMap = new groovy.json.JsonSlurper().parseText(versionsJson)
  //          
  //          // Parse yaml content
  //          def yaml = new org.yaml.snakeyaml.Yaml()
  //          def yamlData = yaml.load(yamlFile)
  //          
  //          // Update versions in yamlData.dockers
  //          versionsMap.each {
  //             artifactId, version ->
  //             // Find key by artifactId suffix (e.g. "cora-docker-solr" -> key "solr")
  //             def key = null
  //             if (artifactId.contains("solr")) key = "solr"
  //             else if (artifactId.contains("idplogin")) key = "idplogin"
  //             else if (artifactId.contains("rabbitmq")) key = "rabbitmq"
  //             else if (artifactId.contains("fedora")) key = "fedora"
  //             else {
  //                // General fallback: use artifact name after last dash
  //                def parts = artifactId.split('-')
  //                key = parts[-1]
  //             }
  //             
  //             if (key && yamlData.dockers.containsKey(key)) {
  //                yamlData.dockers[key] = "${artifactId}:${version}"
  //             }
  //          }
  //          
  //          // Write back updated yaml
  //          def newYamlStr = yaml.dump(yamlData)
  //          writeFile file: 'values.yaml', text: newYamlStr
  //       }
  //    }
  // }
  // stage("commit updates") {
  //    steps {
  //       dir ("$UB_PROJECT_NAME") {
  //          sh 'git config user.email "jenkins@ub"'
   //         sh 'git config user.name "Jenkins CI"'
   //         script {
    //           CHECKED_IN = sh (script: 'git commit -am="Update helm chart"', returnStatus: true, returnStdout: true)
    //        }
    //     }
     // }
   //}
}